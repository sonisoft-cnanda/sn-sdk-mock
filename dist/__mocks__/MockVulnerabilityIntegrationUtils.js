"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockVulnerabilityIntegrationUtils = void 0;
class MockVulnerabilityIntegrationUtils {
    constructor() {
        this._MAX_PROC_TIME_S = 3600; // 60 min.
        this._MAX_RETRIES = 5; // Max retry count.
        this.addIntegrationRun = jest.fn((integrationGr, optInitialState = "ready") => {
            return "mockIntegrationRunId"; // Simulating an inserted record ID.
        });
        this._checkWhetherToRun = jest.fn((integrationGr) => {
            return null; // Simulating no conflicting runs.
        });
        this._checkExistingRunInReady = jest.fn((integrationGr) => {
            return false; // Simulating no existing "ready" state runs.
        });
        this.shouldStartIntegrationRun = jest.fn((integrationRunGr) => {
            return true; // Mocking that it should start.
        });
        this.markProcessAsTimeOut = jest.fn((integrations, agentcorrelatorMap, timeOut) => {
            // Simulated timeout logic.
        });
        this._handleLongRunningProcess = jest.fn((correlators, rangeStarting, timeOut) => {
            // Mock handling long-running processes.
        });
        this.getNextIntegrationRun = jest.fn((integrationSysId) => {
            return null; // Simulating no available runs.
        });
        this._isThirdPartyEntryIntegration = jest.fn((integrationGr) => {
            return false; // Simulating not a third-party integration.
        });
        this.onIntegrationRunComplete = jest.fn((integrationRun) => {
            // Mocking behavior on completion.
        });
        this.startIntegrationRun = jest.fn((runGr) => {
            runGr.state = "running";
            return "mockProcessRunId";
        });
        this._getBackgroundJobRunning = jest.fn((jobList) => {
            return null; // Simulating no running background job.
        });
        this._checkWhetherProofGranularityJobRunning = jest.fn(() => {
            return false; // Simulating no proof granularity job running.
        });
        this.updateIntegrationRun = jest.fn((runGr, state, substate, notes, fatal_error_id, fatal_error_message, parameterRaw, parameterDisplay) => {
            // Mock updating an integration run.
        });
        this.updateIntegrationProcess = jest.fn((procGr, state, notes) => {
            // Mock updating an integration process.
        });
        this.addProcessRun = jest.fn((runGr, parameters) => {
            return "mockProcessRunId"; // Simulating a process run creation.
        });
        this.kickTimedOutIntegrationRuns = jest.fn(() => {
            // Mock kicking out timed-out runs.
        });
        this.cleanupOldProcessAttachments = jest.fn(() => {
            // Mocking cleanup process.
        });
        this.getIntegrationRunRecord = jest.fn((integrationProcessGr) => {
            return null; // Simulating no matching record.
        });
        this.retryProcesses = jest.fn(() => {
            // Mock retrying errored and cancelled processes.
        });
        this.retryCancelledProcesses = jest.fn(() => {
            // Mock retrying cancelled processes.
        });
        this.retryErroredProcesses = jest.fn(() => {
            // Mock retrying errored processes.
        });
        this._retryErroredProcess = jest.fn((intProcGr) => {
            // Mock retrying an errored process.
        });
        this._copyProcess = jest.fn((intProcGr, isProcessErrored) => {
            return "mockNewProcessId"; // Simulating process copy.
        });
        this.haltIntegrationRun = jest.fn((scopeId, runList) => {
            return runList.length; // Simulating the number of halted runs.
        });
        this._deleteIntegrationProcess = jest.fn((integrationRunList) => {
            return []; // Simulating deletion.
        });
        this._deleteQueueEntry = jest.fn((integrationProcessList) => {
            // Mocking queue entry deletion.
        });
        this.deleteIntegrationData = jest.fn((sourceName) => {
            // Mocking data deletion.
        });
        this.mergeJSON = jest.fn((json, jsonContent) => {
            return { ...json, ...jsonContent }; // Merging objects.
        });
        this.checkIfNeedsProcessing = jest.fn((integrationGr) => {
            return false; // Simulating no processing needed.
        });
    }
}
exports.MockVulnerabilityIntegrationUtils = MockVulnerabilityIntegrationUtils;
//# sourceMappingURL=MockVulnerabilityIntegrationUtils.js.map