"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockVulnerabilityIntegrationBase = void 0;
const glide_1 = require("@servicenow/glide");
const sn_vul_1 = require("@servicenow/glide/sn_vul");
const ActualBaseClass = jest.requireActual('@servicenow/glide/sn_vul').VulnerabilityIntegrationBase;
class MockVulnerabilityIntegrationBase extends ActualBaseClass {
    constructor() {
        super(...arguments);
        this.integrationGr = null;
        this.integrationProcessGr = null;
        this.sizeLimitExceeded = false;
        this._nextRunParams = null;
        this._hasMoreData = false;
    }
    initialize() { }
    retrieveData() {
        return {
            contents: "",
            contentType: "",
            extension: ""
        };
    }
    hasMoreData(optBoolean) {
        if (optBoolean != null) {
            this._hasMoreData = optBoolean;
        }
        return this._hasMoreData;
    }
    finalizeRun() {
        return true;
    }
    deleteAttachments(tableName, recordSysId) {
        const attachment = new glide_1.GlideRecord("sys_attachment");
        attachment.addQuery("table_name", tableName);
        attachment.addQuery("table_sys_id", recordSysId);
        attachment.query();
        const attachUtil = new glide_1.GlideSysAttachment();
        while (attachment.next()) {
            glide_1.gs.info("Deleting the attachment: " + attachment.file_name);
            attachUtil.deleteAttachment(attachment.getUniqueValue());
        }
    }
    getNextRunParameters() {
        return this._nextRunParams;
    }
    setNextRunParameters(paramObject) {
        this._nextRunParams = paramObject;
    }
    _getProcessParameters() {
        if (glide_1.gs.nil(this.integrationProcessGr) || glide_1.gs.nil(this.integrationProcessGr.parameters)) {
            return null;
        }
        try {
            const encodedParams = this.integrationProcessGr.getValue("parameters");
            return JSON.parse(encodedParams);
        }
        catch (e) {
            glide_1.gs.warn("Encountered error parsing process parameters, treating as null parameters");
            glide_1.gs.warn(e);
            return null;
        }
    }
    _getRunParameters() {
        if (glide_1.gs.nil(this.integrationProcessGr) ||
            glide_1.gs.nil(this.integrationProcessGr.integration_run) ||
            glide_1.gs.nil(this.integrationProcessGr.integration_run.parameters)) {
            return null;
        }
        try {
            const encodedParams = this.integrationProcessGr.integration_run.parameters + "";
            return JSON.parse(encodedParams);
        }
        catch (e) {
            glide_1.gs.warn("Encountered error parsing run parameters, treating as null parameters");
            glide_1.gs.warn(e);
            return null;
        }
    }
    validateRetrievedData(result) {
        return true;
    }
    validateAttachmentSize(report, process) {
        this.sizeLimitExceeded = false;
        const maxSize = glide_1.gs.getProperty('sn_sec_cmn.max_integration_payload_size');
        const attachment = new glide_1.GlideRecord('sys_attachment');
        if (report && report.contents && attachment.get(report.contents.toString()) && parseInt(attachment.size_bytes) > parseInt(maxSize)) {
            this.sizeLimitExceeded = true;
            throw glide_1.gs.getMessage("Error: The payload attachment size is {0} bytes. It cannot exceed {1} bytes. Modify the integration instance parameters to ensure that the payload attachment size is within the specified limit.", [attachment.size_bytes, maxSize]);
        }
    }
    skipRetryByScheduleJob(integrationProcessGr) {
        return false;
    }
    shouldRetry(process) {
        return false;
    }
    getNextRetry(retry) {
        if (typeof retry === 'string') {
            retry = parseInt(retry);
        }
        return Math.pow(2, (retry + 1));
    }
    getMaxRetry() {
        return 5;
    }
    onDataProcessed(process, result) {
        if (this.integrationGr.report_processor_strategy + "" == "DATA_SOURCE") {
            this._updateIntegrationProcess(process, 'waitComplete');
        }
        else {
            this._updateIntegrationProcess(process, 'complete');
        }
    }
    countDownloadedAttachmets(process) {
        this.countProcesses(process);
    }
    countProcesses(process) {
        let comp = 0;
        let wait = 0;
        const ga = new glide_1.GlideAggregate("sn_vul_integration_process");
        ga.addQuery("integration_run", process.integration_run + "");
        ga.addQuery("state", "IN", "complete,waitComplete");
        ga.groupBy("state");
        ga.addAggregate("COUNT");
        ga.query();
        while (ga.next()) {
            if (ga.getValue("state") == "complete") {
                comp = parseInt(ga.getAggregate("COUNT"));
            }
            else if (ga.getValue("state") == "waitComplete") {
                wait = parseInt(ga.getAggregate("COUNT"));
            }
        }
        const run = new glide_1.GlideRecord("sn_vul_integration_run");
        run.addQuery("sys_id", process.integration_run + "");
        run.setLimit(1);
        run.query();
        if (run.next()) {
            run.setValue("downloaded_attach", comp + wait);
            run.setValue("processed_attach", comp);
            run.setValue("percent_complete", (comp / (comp + wait)) * 100);
            run.update();
        }
    }
    onImportQueueProcessed(process) {
        let entryGr = new glide_1.GlideRecord("sn_vul_ds_import_q_entry");
        entryGr.addQuery("integration_process", process.getUniqueValue());
        entryGr.addQuery("status", "NOT IN", "COMPLETE,ERROR");
        entryGr.setLimit(1);
        entryGr.query();
        if (entryGr.next()) {
            return; // We still have items in progress
        }
        entryGr = new glide_1.GlideRecord("sn_vul_ds_import_q_entry");
        entryGr.addQuery("integration_process", process.getUniqueValue());
        entryGr.addQuery("status", "ERROR");
        entryGr.setLimit(1);
        entryGr.query();
        if (entryGr.next()) {
            this._updateIntegrationProcess(process, "complete", "Some import queue entries are in error");
            return;
        }
        this._updateIntegrationProcess(process, "complete");
        this.countProcessedAttachment(process);
    }
    countProcessedAttachment(process) {
        this.countProcesses(process);
    }
    _updateIntegrationProcess(procGr, state, notes) {
        procGr.setValue('state', state);
        if (notes) {
            procGr.setValue('notes', notes);
        }
        procGr.update();
    }
    onProcessComplete(process) {
        let isComplete = false;
        let isError = false;
        const integrationRun = process.integration_run;
        if (!integrationRun) {
            return;
        }
        const totals = this._calculateCount(integrationRun);
        if (integrationRun.state + "" == "waitComplete") {
            isComplete = this._checkInteRunComplete(integrationRun);
        }
        if (isComplete) {
            isError = this._checkInteRunError(integrationRun);
        }
        this._updateIntegrationRun(integrationRun, isComplete, isError, totals);
    }
    onRunWaitForComplete(integrationRun) {
        let isComplete = false;
        let isError = false;
        if (!integrationRun) {
            return;
        }
        const totals = this._calculateCount(integrationRun);
        if (integrationRun.state + "" == "waitComplete") {
            isComplete = this._checkInteRunComplete(integrationRun);
        }
        if (isComplete) {
            isError = this._checkInteRunError(integrationRun);
        }
        this._updateIntegrationRun(integrationRun.getUniqueValue(), isComplete, isError, totals);
    }
    _checkInteRunComplete(integrationGr) {
        const entryGr = new glide_1.GlideRecord("sn_vul_ds_import_q_entry");
        entryGr.addQuery("integration_process.integration_run", integrationGr.sys_id + "");
        entryGr.addQuery('status', 'NOT IN', 'COMPLETE,ERROR');
        entryGr.setLimit(1);
        entryGr.query();
        return !(entryGr.hasNext());
    }
    _checkInteRunError(integrationGr) {
        const entryGr = new glide_1.GlideRecord("sn_vul_ds_import_q_entry");
        entryGr.addQuery("integration_process.integration_run", integrationGr.sys_id + "");
        entryGr.addQuery('status', 'ERROR');
        entryGr.setLimit(1);
        entryGr.query();
        return entryGr.hasNext();
    }
    _updateIntegrationRun(runGrId, isComplete, isError, totals) {
        const runGr = new glide_1.GlideRecord("sn_vul_integration_run");
        if (!runGr.get(runGrId)) {
            return;
        }
        runGr.setValue("import_vi", totals.import_vi);
        runGr.setValue("vi_created", totals.vi_created);
        runGr.setValue("vi_updated", totals.vi_updated);
        runGr.setValue("vi_new_findings", totals.vi_updated_new_findings);
        runGr.setValue("vi_unchanged", totals.vi_unchanged);
        runGr.setValue("vi_duplicates", totals.vi_duplicates);
        runGr.setValue("vi_ignored", totals.vi_ignored);
        runGr.setValue("det_created", totals.det_created);
        runGr.setValue("det_updated", totals.det_updated);
        runGr.setValue("det_unchanged", totals.det_unchanged);
        runGr.setValue("det_ignored", totals.det_ignored);
        runGr.setValue("det_excluded", totals.det_excluded);
        runGr.setValue("import_ci", totals.import_ci);
        runGr.setValue("ci_created", totals.ci_created);
        runGr.setValue("ci_identified", totals.ci_identified);
        runGr.setValue("ci_ignored", totals.ci_ignored);
        runGr.update();
        if (isComplete) {
            const util = new sn_vul_1.VulnerabilityIntegrationUtils();
            const state = 'complete';
            const substate = isError ? 'failed' : 'success';
            const notes = isError ?
                glide_1.gs.getMessage("At least one import queue entry is in error.  No more data to process at this time.") :
                glide_1.gs.getMessage("Successfully completed integration run.  No more data to process at this time.");
            util.updateIntegrationRun(runGr, state, substate, notes);
        }
    }
    _calculateCount(inteRun) {
        const totals = {
            import_vi: 0,
            vi_created: 0,
            vi_updated: 0,
            vi_unchanged: 0,
            vi_duplicates: 0,
            vi_ignored: 0,
            det_created: 0,
            det_updated: 0,
            det_unchanged: 0,
            det_excluded: 0,
            det_ignored: 0,
            import_ci: 0,
            ci_created: 0,
            ci_identified: 0,
            ci_ignored: 0,
            vi_updated_new_findings: 0
        };
        const processGr = new glide_1.GlideAggregate("sn_vul_integration_process");
        processGr.addQuery("integration_run", inteRun.sys_id + "");
        processGr.addAggregate('SUM', 'import_vi');
        processGr.addAggregate('SUM', 'vi_created');
        processGr.addAggregate('SUM', 'vi_updated');
        processGr.addAggregate('SUM', 'vi_new_findings');
        processGr.addAggregate('SUM', 'vi_unchanged');
        processGr.addAggregate('SUM', 'vi_ignored');
        processGr.addAggregate('SUM', 'vi_duplicates');
        processGr.addAggregate('SUM', 'det_created');
        processGr.addAggregate('SUM', 'det_updated');
        processGr.addAggregate('SUM', 'det_unchanged');
        processGr.addAggregate('SUM', 'det_ignored');
        processGr.addAggregate('SUM', 'det_excluded');
        processGr.addAggregate('SUM', 'import_ci');
        processGr.addAggregate('SUM', 'ci_created');
        processGr.addAggregate('SUM', 'ci_identified');
        processGr.addAggregate('SUM', 'ci_ignored');
        processGr.setGroup(false);
        processGr.query();
        if (processGr.next()) {
            totals.import_vi = parseInt(processGr.getAggregate('SUM', 'import_vi'));
            totals.vi_created = parseInt(processGr.getAggregate('SUM', 'vi_created'));
            totals.vi_updated = parseInt(processGr.getAggregate('SUM', 'vi_updated'));
            totals.vi_updated_new_findings = parseInt(processGr.getAggregate('SUM', 'vi_new_findings'));
            totals.vi_unchanged = parseInt(processGr.getAggregate('SUM', 'vi_unchanged'));
            totals.vi_ignored = parseInt(processGr.getAggregate('SUM', 'vi_ignored'));
            totals.vi_duplicates = parseInt(processGr.getAggregate('SUM', 'vi_duplicates'));
            totals.det_created = parseInt(processGr.getAggregate('SUM', 'det_created'));
            totals.det_updated = parseInt(processGr.getAggregate('SUM', 'det_updated'));
            totals.det_unchanged = parseInt(processGr.getAggregate('SUM', 'det_unchanged'));
            totals.det_ignored = parseInt(processGr.getAggregate('SUM', 'det_ignored'));
            totals.det_excluded = parseInt(processGr.getAggregate('SUM', 'det_excluded'));
            totals.import_ci = parseInt(processGr.getAggregate('SUM', 'import_ci'));
            totals.ci_created = parseInt(processGr.getAggregate('SUM', 'ci_created'));
            totals.ci_identified = parseInt(processGr.getAggregate('SUM', 'ci_identified'));
            totals.ci_ignored = parseInt(processGr.getAggregate('SUM', 'ci_ignored'));
        }
        return totals;
    }
    isProcessStartedByFramework(process) {
        return true;
    }
    validateXML(body, errorNodeName) {
        if (!body)
            return;
        const doc = new glide_1.XMLDocument2();
        doc.parseXML(body);
        let err = null;
        try {
            const root = doc.getFirstNode('/' + doc.getDocumentElement().getNodeName());
            if (errorNodeName && root.getNodeName() == errorNodeName) {
                err = root.getTextContent();
            }
            else {
                doc.getNextNode(root);
            }
        }
        catch (e) {
            throw 'XML document syntax invalid';
        }
        if (err) {
            throw 'Integration responded with: ' + err;
        }
    }
    _shouldAutoTruncate(process) {
        const gr = new glide_1.GlideAggregate("sn_vul_integration_process");
        gr.addEncodedQuery('parametersLIKE"truncation"^stateINcomplete,waitComplete^integration_run=' + process.integration_run + "");
        gr.addAggregate("COUNT");
        gr.query();
        if (gr.next()) {
            return parseInt(gr.getAggregate("COUNT")) < 5;
        }
        return true;
    }
    _getTruncationLimit(actualTruncation, currentSize, threshold) {
        const truncation = actualTruncation * (threshold / currentSize);
        if (glide_1.gs.nil(truncation) || truncation <= 0) {
            return actualTruncation;
        }
        return truncation;
    }
    getStatusCodeMessage(statusCode, placeholder) {
        return (new sn_vul_1.VulnerabilityUtils()).getStatusCodeMessage(statusCode, placeholder);
    }
    type() {
        return 'VulnerabilityIntegrationBase';
    }
}
exports.MockVulnerabilityIntegrationBase = MockVulnerabilityIntegrationBase;
//# sourceMappingURL=MockVulnerabilityIntegrationBase.js.map