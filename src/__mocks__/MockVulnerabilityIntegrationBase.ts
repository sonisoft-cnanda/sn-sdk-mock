import { GlideAggregate, GlideRecord, GlideSysAttachment, gs, XMLDocument2 } from "@servicenow/glide";
import { VulnerabilityIntegrationUtils, VulnerabilityUtils } from "@servicenow/glide/sn_vul";

const ActualBaseClass = jest.requireActual('@servicenow/glide/sn_vul').VulnerabilityIntegrationBase;


export class MockVulnerabilityIntegrationBase extends ActualBaseClass{
    integrationGr: any = null;
    integrationProcessGr: any = null;
    sizeLimitExceeded: boolean = false;
    _nextRunParams: any = null;
    _hasMoreData: boolean = false;

    initialize() {}

    retrieveData() {
        return {
            contents: "",
            contentType: "",
            extension: ""
        };
    }

    hasMoreData(optBoolean: boolean) {
        if (optBoolean != null) {
            this._hasMoreData = optBoolean;
        }
        return this._hasMoreData;
    }

    finalizeRun() {
        return true;
    }

    deleteAttachments(tableName: string, recordSysId: string) {
        const attachment:any = new GlideRecord("sys_attachment");
        attachment.addQuery("table_name", tableName);
        attachment.addQuery("table_sys_id", recordSysId);
        attachment.query();
        const attachUtil = new GlideSysAttachment();
        while (attachment.next()) {
            gs.info("Deleting the attachment: " + attachment.file_name);
            attachUtil.deleteAttachment(attachment.getUniqueValue());
        }
    }

    getNextRunParameters() {
        return this._nextRunParams;
    }

    setNextRunParameters(paramObject: any) {
        this._nextRunParams = paramObject;
    }

    _getProcessParameters() {
        if (gs.nil(this.integrationProcessGr) || gs.nil(this.integrationProcessGr.parameters)) {
            return null;
        }
        try {
            const encodedParams = this.integrationProcessGr.getValue("parameters");
           
            return JSON.parse(encodedParams);
        } catch (e) {
            gs.warn("Encountered error parsing process parameters, treating as null parameters");
            gs.warn(e);
            return null;
        }
    }

    _getRunParameters() {
        if (gs.nil(this.integrationProcessGr) ||
            gs.nil(this.integrationProcessGr.integration_run) ||
            gs.nil(this.integrationProcessGr.integration_run.parameters)) {
            return null;
        }
        try {
            const encodedParams = this.integrationProcessGr.integration_run.parameters + "";
           
            return JSON.parse(encodedParams);
        } catch (e) {
            gs.warn("Encountered error parsing run parameters, treating as null parameters");
            gs.warn(e);
            return null;
        }
    }

    validateRetrievedData(result: any) {
        return true;
    }

    validateAttachmentSize(report: any, process: any) {
        this.sizeLimitExceeded = false;
        const maxSize = gs.getProperty('sn_sec_cmn.max_integration_payload_size');
        const attachment:any = new GlideRecord('sys_attachment');
        if (report && report.contents && attachment.get(report.contents.toString()) && parseInt(attachment.size_bytes) > parseInt(maxSize)) {
            this.sizeLimitExceeded = true;
            throw gs.getMessage("Error: The payload attachment size is {0} bytes. It cannot exceed {1} bytes. Modify the integration instance parameters to ensure that the payload attachment size is within the specified limit.", [attachment.size_bytes, maxSize]);
        }
    }

    skipRetryByScheduleJob(integrationProcessGr: any) {
        return false;
    }

    shouldRetry(process: any) {
        return false;
    }

    getNextRetry(retry: number | string) {
        if(typeof retry === 'string') {
            retry = parseInt(retry);
        }

        return Math.pow(2, (retry + 1));
    }

    getMaxRetry() {
        return 5;
    }

    onDataProcessed(process: any, result: any) {
        if (this.integrationGr.report_processor_strategy + "" == "DATA_SOURCE") {
            this._updateIntegrationProcess(process, 'waitComplete');
        } else {
            this._updateIntegrationProcess(process, 'complete');
        }
    }

    countDownloadedAttachmets(process: any) {
        this.countProcesses(process);
    }

    countProcesses(process: any) {
        let comp = 0;
        let wait = 0;
        const ga = new GlideAggregate("sn_vul_integration_process");
        ga.addQuery("integration_run", process.integration_run + "");
        ga.addQuery("state", "IN", "complete,waitComplete");
        ga.groupBy("state");
        ga.addAggregate("COUNT");
        ga.query();
        while (ga.next()) {
            if (ga.getValue("state") == "complete") {
                comp = parseInt(ga.getAggregate("COUNT"));
            } else if (ga.getValue("state") == "waitComplete") {
                wait = parseInt(ga.getAggregate("COUNT"));
            }
        }
        const run = new GlideRecord("sn_vul_integration_run");
        run.addQuery("sys_id", process.integration_run + "");
        run.setLimit(1);
        run.query();
        if (run.next()) {
            run.setValue("downloaded_attach", comp + wait);
            run.setValue("processed_attach", comp);
            run.setValue("percent_complete", (comp / (comp + wait)) * 100);
            run.update();
        }
    }

    onImportQueueProcessed(process: any) {
        let entryGr = new GlideRecord("sn_vul_ds_import_q_entry");
        entryGr.addQuery("integration_process", process.getUniqueValue());
        entryGr.addQuery("status", "NOT IN", "COMPLETE,ERROR");
        entryGr.setLimit(1);
        entryGr.query();
        if (entryGr.next()) {
            return; // We still have items in progress
        }
        entryGr = new GlideRecord("sn_vul_ds_import_q_entry");
        entryGr.addQuery("integration_process", process.getUniqueValue());
        entryGr.addQuery("status", "ERROR");
        entryGr.setLimit(1);
        entryGr.query();
        if (entryGr.next()) {
            this._updateIntegrationProcess(process, "complete", "Some import queue entries are in error");
            return;
        }
        this._updateIntegrationProcess(process, "complete");
        this.countProcessedAttachment(process);
    }

    countProcessedAttachment(process: any) {
        this.countProcesses(process);
    }

    _updateIntegrationProcess(procGr: any, state: string, notes?: string) {
        procGr.setValue('state', state);
        if (notes) {
            procGr.setValue('notes', notes);
        }
        procGr.update();
    }

    onProcessComplete(process: any) {
        let isComplete = false;
        let isError = false;

        const integrationRun = process.integration_run;
        if (!integrationRun) {
            return;
        }
        const totals = this._calculateCount(integrationRun);
        if (integrationRun.state + "" == "waitComplete") {
            isComplete = this._checkInteRunComplete(integrationRun);
        }
        if (isComplete) {
            isError = this._checkInteRunError(integrationRun);
        }
        this._updateIntegrationRun(integrationRun, isComplete, isError, totals);
    }

    onRunWaitForComplete(integrationRun: any) {
        let isComplete = false;
        let isError = false;
        if (!integrationRun) {
            return;
        }
        const totals = this._calculateCount(integrationRun);
        if (integrationRun.state + "" == "waitComplete") {
            isComplete = this._checkInteRunComplete(integrationRun);
        }
        if (isComplete) {
            isError = this._checkInteRunError(integrationRun);
        }
        this._updateIntegrationRun(integrationRun.getUniqueValue(), isComplete, isError, totals);
    }

    _checkInteRunComplete(integrationGr: any) {
        const entryGr = new GlideRecord("sn_vul_ds_import_q_entry");
        entryGr.addQuery("integration_process.integration_run", integrationGr.sys_id + "");
        entryGr.addQuery('status', 'NOT IN', 'COMPLETE,ERROR');
        entryGr.setLimit(1);
        entryGr.query();
        return !(entryGr.hasNext());
    }

    _checkInteRunError(integrationGr: any) {
        const entryGr = new GlideRecord("sn_vul_ds_import_q_entry");
        entryGr.addQuery("integration_process.integration_run", integrationGr.sys_id + "");
        entryGr.addQuery('status', 'ERROR');
        entryGr.setLimit(1);
        entryGr.query();
        return entryGr.hasNext();
    }

    _updateIntegrationRun(runGrId: string, isComplete: boolean, isError: boolean, totals: any) {
        const runGr = new GlideRecord("sn_vul_integration_run");
        if (!runGr.get(runGrId)) {
            return;
        }
        runGr.setValue("import_vi", totals.import_vi);
        runGr.setValue("vi_created", totals.vi_created);
        runGr.setValue("vi_updated", totals.vi_updated);
        runGr.setValue("vi_new_findings", totals.vi_updated_new_findings);
        runGr.setValue("vi_unchanged", totals.vi_unchanged);
        runGr.setValue("vi_duplicates", totals.vi_duplicates);
        runGr.setValue("vi_ignored", totals.vi_ignored);
        runGr.setValue("det_created", totals.det_created);
        runGr.setValue("det_updated", totals.det_updated);
        runGr.setValue("det_unchanged", totals.det_unchanged);
        runGr.setValue("det_ignored", totals.det_ignored);
        runGr.setValue("det_excluded", totals.det_excluded);
        runGr.setValue("import_ci", totals.import_ci);
        runGr.setValue("ci_created", totals.ci_created);
        runGr.setValue("ci_identified", totals.ci_identified);
        runGr.setValue("ci_ignored", totals.ci_ignored);
        runGr.update();

        if (isComplete) {
            const util = new VulnerabilityIntegrationUtils();
            const state = 'complete';
            const substate = isError ? 'failed' : 'success';
            const notes = isError ?
                gs.getMessage("At least one import queue entry is in error.  No more data to process at this time.") :
                gs.getMessage("Successfully completed integration run.  No more data to process at this time.");

            util.updateIntegrationRun(runGr, state, substate, notes);
        }
    }

    _calculateCount(inteRun: any) {
        const totals = {
            import_vi: 0,
            vi_created: 0,
            vi_updated: 0,
            vi_unchanged: 0,
            vi_duplicates: 0,
            vi_ignored: 0,
            det_created: 0,
            det_updated: 0,
            det_unchanged: 0,
            det_excluded: 0,
            det_ignored: 0,
            import_ci: 0,
            ci_created: 0,
            ci_identified: 0,
            ci_ignored: 0,
            vi_updated_new_findings: 0
        };
        const processGr = new GlideAggregate("sn_vul_integration_process");
        processGr.addQuery("integration_run", inteRun.sys_id + "");
        processGr.addAggregate('SUM', 'import_vi');
        processGr.addAggregate('SUM', 'vi_created');
        processGr.addAggregate('SUM', 'vi_updated');
        processGr.addAggregate('SUM', 'vi_new_findings');
        processGr.addAggregate('SUM', 'vi_unchanged');
        processGr.addAggregate('SUM', 'vi_ignored');
        processGr.addAggregate('SUM', 'vi_duplicates');
        processGr.addAggregate('SUM', 'det_created');
        processGr.addAggregate('SUM', 'det_updated');
        processGr.addAggregate('SUM', 'det_unchanged');
        processGr.addAggregate('SUM', 'det_ignored');
        processGr.addAggregate('SUM', 'det_excluded');
        processGr.addAggregate('SUM', 'import_ci');
        processGr.addAggregate('SUM', 'ci_created');
        processGr.addAggregate('SUM', 'ci_identified');
        processGr.addAggregate('SUM', 'ci_ignored');
        processGr.setGroup(false);
        processGr.query();
        if (processGr.next()) {
            totals.import_vi = parseInt(processGr.getAggregate('SUM', 'import_vi'));
            totals.vi_created = parseInt(processGr.getAggregate('SUM', 'vi_created'));
            totals.vi_updated = parseInt(processGr.getAggregate('SUM', 'vi_updated'));
            totals.vi_updated_new_findings = parseInt(processGr.getAggregate('SUM', 'vi_new_findings'));
            totals.vi_unchanged = parseInt(processGr.getAggregate('SUM', 'vi_unchanged'));
            totals.vi_ignored = parseInt(processGr.getAggregate('SUM', 'vi_ignored'));
            totals.vi_duplicates = parseInt(processGr.getAggregate('SUM', 'vi_duplicates'));
            totals.det_created = parseInt(processGr.getAggregate('SUM', 'det_created'));
            totals.det_updated = parseInt(processGr.getAggregate('SUM', 'det_updated'));
            totals.det_unchanged = parseInt(processGr.getAggregate('SUM', 'det_unchanged'));
            totals.det_ignored = parseInt(processGr.getAggregate('SUM', 'det_ignored'));
            totals.det_excluded = parseInt(processGr.getAggregate('SUM', 'det_excluded'));
            totals.import_ci = parseInt(processGr.getAggregate('SUM', 'import_ci'));
            totals.ci_created = parseInt(processGr.getAggregate('SUM', 'ci_created'));
            totals.ci_identified = parseInt(processGr.getAggregate('SUM', 'ci_identified'));
            totals.ci_ignored = parseInt(processGr.getAggregate('SUM', 'ci_ignored'));
        }
        return totals;
    }

    isProcessStartedByFramework(process: any) {
        return true;
    }

    validateXML(body: string, errorNodeName?: string) {
        if (!body) return;

        const doc = new XMLDocument2();
        doc.parseXML(body);

        let err = null;

        try {
            const root = doc.getFirstNode('/' + doc.getDocumentElement().getNodeName());

            if (errorNodeName && root.getNodeName() == errorNodeName) {
                err = root.getTextContent();
            } else {
                doc.getNextNode(root);
            }
        } catch (e) {
            throw 'XML document syntax invalid';
        }

        if (err) {
            throw 'Integration responded with: ' + err;
        }
    }

    _shouldAutoTruncate(process: any) {
        const gr = new GlideAggregate("sn_vul_integration_process");
        gr.addEncodedQuery('parametersLIKE"truncation"^stateINcomplete,waitComplete^integration_run=' + process.integration_run + "");
        gr.addAggregate("COUNT");
        gr.query();
        if (gr.next()) {
            return parseInt(gr.getAggregate("COUNT")) < 5;
        }
        return true;
    }

    _getTruncationLimit(actualTruncation: number, currentSize: number, threshold: number) {
        const truncation = actualTruncation * (threshold / currentSize);
        if (gs.nil(truncation) || truncation <= 0) {
            return actualTruncation;
        }
        return truncation;
    }

    getStatusCodeMessage(statusCode: number, placeholder: string) {
        return (new VulnerabilityUtils()).getStatusCodeMessage(statusCode, placeholder);
    }

    type() {
        return 'VulnerabilityIntegrationBase';
    }
}