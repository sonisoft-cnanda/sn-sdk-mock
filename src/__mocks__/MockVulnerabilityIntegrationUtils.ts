export class VulnerabilityIntegrationUtils {
    _MAX_PROC_TIME_S = 3600; // 60 min.
    _MAX_RETRIES = 5; // Max retry count.
  
    constructor() {}
  
    addIntegrationRun = jest.fn((integrationGr, optInitialState = "ready") => {
      return "mockIntegrationRunId"; // Simulating an inserted record ID.
    });
  
    _checkWhetherToRun = jest.fn((integrationGr) => {
      return null; // Simulating no conflicting runs.
    });
  
    _checkExistingRunInReady = jest.fn((integrationGr) => {
      return false; // Simulating no existing "ready" state runs.
    });
  
    shouldStartIntegrationRun = jest.fn((integrationRunGr) => {
      return true; // Mocking that it should start.
    });
  
    markProcessAsTimeOut = jest.fn((integrations, agentcorrelatorMap, timeOut) => {
      // Simulated timeout logic.
    });
  
    _handleLongRunningProcess = jest.fn((correlators, rangeStarting, timeOut) => {
      // Mock handling long-running processes.
    });
  
    getNextIntegrationRun = jest.fn((integrationSysId) => {
      return null; // Simulating no available runs.
    });
  
    _isThirdPartyEntryIntegration = jest.fn((integrationGr) => {
      return false; // Simulating not a third-party integration.
    });
  
    onIntegrationRunComplete = jest.fn((integrationRun) => {
      // Mocking behavior on completion.
    });
  
    startIntegrationRun = jest.fn((runGr) => {
      runGr.state = "running";
      return "mockProcessRunId";
    });
  
    _getBackgroundJobRunning = jest.fn((jobList) => {
      return null; // Simulating no running background job.
    });
  
    _checkWhetherProofGranularityJobRunning = jest.fn(() => {
      return false; // Simulating no proof granularity job running.
    });
  
    updateIntegrationRun = jest.fn(
      (runGr, state, substate, notes, fatal_error_id, fatal_error_message, parameterRaw, parameterDisplay) => {
        // Mock updating an integration run.
      }
    );
  
    updateIntegrationProcess = jest.fn((procGr, state, notes) => {
      // Mock updating an integration process.
    });
  
    addProcessRun = jest.fn((runGr, parameters) => {
      return "mockProcessRunId"; // Simulating a process run creation.
    });
  
    kickTimedOutIntegrationRuns = jest.fn(() => {
      // Mock kicking out timed-out runs.
    });
  
    cleanupOldProcessAttachments = jest.fn(() => {
      // Mocking cleanup process.
    });
  
    getIntegrationRunRecord = jest.fn((integrationProcessGr) => {
      return null; // Simulating no matching record.
    });
  
    retryProcesses = jest.fn(() => {
      // Mock retrying errored and cancelled processes.
    });
  
    retryCancelledProcesses = jest.fn(() => {
      // Mock retrying cancelled processes.
    });
  
    retryErroredProcesses = jest.fn(() => {
      // Mock retrying errored processes.
    });
  
    _retryErroredProcess = jest.fn((intProcGr) => {
      // Mock retrying an errored process.
    });
  
    _copyProcess = jest.fn((intProcGr, isProcessErrored) => {
      return "mockNewProcessId"; // Simulating process copy.
    });
  
    haltIntegrationRun = jest.fn((scopeId, runList) => {
      return runList.length; // Simulating the number of halted runs.
    });
  
    _deleteIntegrationProcess = jest.fn((integrationRunList) => {
      return []; // Simulating deletion.
    });
  
    _deleteQueueEntry = jest.fn((integrationProcessList) => {
      // Mocking queue entry deletion.
    });
  
    deleteIntegrationData = jest.fn((sourceName) => {
      // Mocking data deletion.
    });
  
    mergeJSON = jest.fn((json, jsonContent) => {
      return { ...json, ...jsonContent }; // Merging objects.
    });
  
    checkIfNeedsProcessing = jest.fn((integrationGr) => {
      return false; // Simulating no processing needed.
    });
  }
  